#include "stdafx.h"
#include <iostream>
#include <math.h>
#include <iomanip>
#include <fstream> 
#include <stdio.h>
#include <cstdlib>
#include <vector>

using namespace std;
float PI = 3.14159265358979323846;
//поверхность контактов(A)
float ContactSurf(int r, float R0) {
	return 4 * PI*(r + R0);
}
//число ячеек в слое L
float NumbCell(int r, float R0) {
	return 4 / 3 * PI*(3 * pow((r + R0), 2) - 3 * (r + R0) + 1);
}

void probability(float* LambdB, float* LambdF, float* LambdS, int curru, float R0) {
	float tempLambdB, tempLambdF, tempLambdS;
	tempLambdB = tempLambdF = 1 / 6;
	tempLambdS = 1 - tempLambdB - tempLambdF;//вероятности перехода в плойской геометрии
	*LambdF = tempLambdF*(ContactSurf(curru, R0) / NumbCell(curru, R0));
	*LambdB = tempLambdB*(ContactSurf(curru - 1, R0) / NumbCell(curru, R0));
	*LambdS = 1 - *LambdF - *LambdB;
}

void field(int numblink, int M, int N, float R0, int max_step) {
	float LambdB, LambdF, LambdS;//вероятности перехода в сферической геометрии
	int curru = 0, currs = 1;
	vector<int> uW;//поле полимера
	vector<int> uP;//поле растворителя
	vector<int> s; //номер звена
	uW.resize(M + 2);
	uP.resize(M + 2);
	s.resize(N);
	for (int i = 0; i < M + 2; i++) {
		uW[i] = 0;
		uP[i] = 0;
	}
	for (int i = 0; i < N; i++)
		s[i] = 0;
	float Gp, Gw;
	//vector<float> Gforw{ 0,0,0 };
	vector < vector <int> > Gforw(M + 2, vector <int>(N, 0));
	vector < vector <int> > Gback(M + 2, vector <int>(N, 0));
	for (int i = 0; i < max_step; i++) {
		for (int j = 1; j < N+1; j++) {
			for (int k = 0; k < M + 2; k++) {
				probability(&LambdB, &LambdF, &LambdS, curru, R0);
				Gp = exp(-uP[k]);
				Gw = exp(-uW[k]);
				if (k == 0) {
					Gforw[k][j] = 0;
					Gback[k][j] = 0;
				}
				else if (k == M + 1) {
					Gforw[k][j] = Gforw[k-1][j];
					Gback[k][j] = Gback[k-1][j];
				}
				else {
					Gforw[k][j] = Gp;
					Gback[k][N-j] = Gw;
					Gforw[k+1][j] = exp(-uP[k+1]);
					Gback[k+1][N - j] = exp(-uW[k+1]);
				}
				Gforw[k][j + 1] = Gp*(LambdB*Gforw[k - 1][j] + LambdS*Gforw[k][j] + LambdF*Gforw[k + 1][j]);
				Gforw[k][j -1] = Gp*(LambdB*Gback[k - 1][j] + LambdS*Gforw[k][j] + LambdF*Gback[k + 1][j]);
			}
		}
	}
}





int main()
{
	//setlocale(LC_ALL, "Russian");
	int N, n, M, v, max_step, numblink;
	float del = 0.1, R0 = 0.5;
	ifstream infile("data1.txt");
	infile >> N >> n >> M >> v >> del >> max_step;//нач. парамертры
	infile.close();
	numblink = n*N;//число звеньев
	vector<int> cell1;
	vector<int> cell2;
	cell1.resize(M + 2);
	cell2.resize(N);

	return 0;
}
